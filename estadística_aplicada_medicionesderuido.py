# -*- coding: utf-8 -*-
"""Estadística_aplicada|MedicionesdeRuido.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CjE3pUkavJe73S0jb0XuSfnzH7zUNnso
"""

# Importamos las librerías que vamos a utilizar
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

from pyproj import Proj
import folium
from folium.plugins import MarkerCluster, HeatMap
from scipy import stats
from plotnine import *

# Leemos el conjunto de datos
data = pd.read_excel('/estadisticaaplicada.xlsx')

"""En el archivo de Excel se encuentra la base de datos de muestra con 445 mediciones de ruido, de las cuales se tiene información del Grupo de Exposición Similar (GES) al que corresponde cada muestra y del valor límite permisible (TLV). Teniendo en cuenta las siguientes definiciones:
•	**Grupo de Exposición Similar** (GES): Conjunto de trabajadores en los cuales se asume que se tiene el mismo perfil de exposición de un factor de riesgo determinado, en términos de la frecuencia con que se desarrolla una tarea u oficio, los materiales utilizados y los procesos implicados en general.

•	**Valor Límite Permisible** (TLV): Nivel al que un trabajador puede estar expuesto por turno en el tiempo de trabajo sin efectos adversos.

# Preparación de los datos
"""

# Vemos la información del conjunto de datos
data.info()

"""Hay 445 registros en 4 columnas"""

# Consultamos los primeros valores
data.head()

# Descripción del conjunto de datos
data.describe()

"""El nivel de presión sonora(SPL (dBA)) al que está expuesto el conjunto de colaboradores, nos indica que en promedio el conjunto de colaboradores está expuesto en un 80.36 puntos de presión sonora.
El valor mínimo que presenta es de 63.40 puntos de presión sonora y el valor máximo es de 109.20 puntos de presión sonora.
"""

# Mostramos True si en la columna hay valores nulos
data.isnull().any()

"""No hay valores nulos en las columnas"""

# Comprobamos si hay datos duplicados
data.duplicated().any()

"""No hay registros duplicados.
Ahora vamos a convertir en numéricos los valores de la columna GES.
"""

# En la columna GES, sustituimos los valores "Operador de Máquina","Operador de Planta","Operador de Taladro","Supervisor" por 0, 1, 2 y 3 para hacer numérica la columna
data['GES'] = data['GES'].map({'Operador de Máquina': 0, 'Operador de Planta': 1, 'Operador de Taladro': 2, 'Supervisor': 3}).astype(int)

# Vemos como queda el conjunto de datos
data.head()

"""# Análisis exploratorio de los datos de muestra."""

# Histograma de las muestras
data.hist(column='SPL (dBA)', by= 'GES',figsize=(15,9), rwidth=0.9)

"""Observamos que los datos medidos de presión sonora para los grupos de exposición similar están sesgados levemente hacia la derecha,"""

# Diagrama de cajas entre las mediciones y el momento de la medición (GES)
sns.boxplot(x='GES',y='SPL (dBA)',data=data).set_title("Mediciones")

"""El diagrama de caja nos muestra que el GES 3( Supervisor) es quien presenta una mediana inferior.Los GES 1( Operador de planta) y GES 2(Operador de Taladro) presentan resultados similares en cuando a su mediana ponderada, también observamos que los gráficos se superponen. Los datos para el GES 1 tienen un tendencia superior a presentar mayor nivel de SPL (dBA) que los del GES 2, sin embargo, el GES 2 presenta un valor atípico muy alejado de los valores esperados de exposición de presión sonora.
El GES 0(Operador de Máquina) presenta una mediana de exposición a la presión sonora más alta que el resto de los GES medidos.
"""

#vamos a ver la frecuencia
(data.groupby("GES").agg(frequency=("GES", "count")))

freq_by_GES = (data.groupby("GES").agg(frequency=("GES", "count")).reset_index())

(ggplot(freq_by_GES, aes(x = "GES", y = "frequency")) +
  geom_bar(stat = 'identity'))

"""Observando la información gráfica,vamos a determinar los supuestos de normalidad se cumplen para nuestros datos de muestra.

**Comprobación de supuestos de normalidad.**

La siguiente prueba está basada en la prueba de D’Agostino y Pearson, que combina sesgo y curtosis para producir una prueba general (omnibus) de normalidad.
"""

# D’Agostino y Pearson
# H_0 Los datos vienen de una distribución normal


stats.normaltest(data)

# Histograma + curva normal teórica
# ==============================================================================

# Valores de la media (mu) y desviación típica (sigma) de los datos
mu, sigma = stats.norm.fit(data['SPL (dBA)'])

# Valores teóricos de la normal en el rango observado
x_hat = np.linspace(min(data['SPL (dBA)']), max(data['SPL (dBA)']), num=100)
y_hat = stats.norm.pdf(x_hat, mu, sigma)

# Gráfico
fig, ax = plt.subplots(figsize=(7,4))

ax.plot(x_hat, y_hat, linewidth=2, label='normal')
ax.hist(x=data['SPL (dBA)'], density=True, bins=30, color="#3182bd", alpha=0.5)
ax.plot(data['SPL (dBA)'], np.full_like(data['SPL (dBA)'], -0.01), '|k', markeredgewidth=1)
ax.set_title('Distribución SPL para los GES')
ax.set_xlabel('Presión sonora')
ax.set_ylabel('Densidad')
ax.legend();

import statsmodels.api as sm
from scipy import stats

# Gráfico Q-Q
# ==============================================================================
fig, ax = plt.subplots(figsize=(7,4))
sm.qqplot(
    data['SPL (dBA)'],
    fit   = True,
    line  = 'q',
    alpha = 0.4,
    lw    = 2,
    ax    = ax
)
ax.set_title('Gráfico Q-Q del SPL para los GES', fontsize = 10,
             fontweight = "bold")
ax.tick_params(labelsize = 7)

# D'Agostino's K-squared test
# ==============================================================================
k2, p_value = stats.normaltest(data['SPL (dBA)'])
print(f"Estadístico = {k2}, p-value = {p_value}")

"""Dadas las evidencias gráficas y tomando en cuenta el test de normalidad,
el p-value de estos test indica la probabilidad de obtener unos datos como los observados como si realmente procediesen de una población con una distribución normal con la misma media y desviación que estos. Por lo tanto, niguno de los test muestra evidencias para rechazar la hipótesis nula de que los datos se distribuyen de forma normal.

Retomemos la frecuencia en que están dados los GES, esto con el fin de conformar nuevos grupos. El GES debe ser conformado por un tamaño de muestra mayor o igual a 5.

# Determinando el GES MAYOR O IGUAL A 5
"""

#vamos a ver la frecuencia
(data.groupby("GES").agg(frequency=("GES", "count")))

"""Vemos que el grupo GES 3(Supervisor), únicamente contiene 4 muestras, Por tanto, para determinar si se considera en el análisis de GES, se considera la siguiente definición:
GES: Conjunto de trabajadores en los cuales se asume que se tiene el mismo perfil de exposición de un factor de riesgo determinado, en términos de la frecuencia con que se desarrolla una tarea u oficio, los materiales utilizados y los procesos implicados en general.

Si tomo en cuenta los demás grupos que estoy analizando, mis otros tres grupos GES son trabajadores pertenecientes a un conjunto de colaboradores que tienen perfiles similares de exposición("Operador de Máquina","Operador de Planta","Operador de Taladro").
Por tal motivo y dando cumplimiento al objetivo de los GES, se elimina la categoría 'Supervisor' de mis datos a analizar, ya que no es factor de estudio para este análisis.
"""

#Removiendo la categoria 'Supervisor' de mi conjunto de datos
data = data[data['GES'] !=3]

print(data)

data.sample(n=10) #confirmando que eliminamos la categoria GES 3

# Histograma de las muestras
data.hist(column='SPL (dBA)', by= 'GES',figsize=(15,9), rwidth=0.9)

"""**Calculo de valores atípicos.**"""

#Calcular el IQR para cada columna

Q1= data.quantile(0.25)
Q3= data.quantile(0.75)
IQR= Q3 - Q1

#Definiendo los limites para determinar outliers
lim_infe= Q1 - 1.5 * IQR
lim_sup= Q3 + 1.5* IQR

#Filtrando las filas que no tienen outliers en ninguna columna
data_filtrado = data[((data >= lim_infe) & (data <= lim_sup)).all(axis=1)]

print(data_filtrado)

"""De los 445 registros que se tenían inicialmente, 438 registros quedaron después de eliminar los valores atípicos de nuestra muestra de datos de medición de ruido."""

# Histograma de las muestras sin outliers
data_filtrado.hist(column='SPL (dBA)', by= 'GES',figsize=(15,9), rwidth=0.9)

# Diagrama de cajas entre las mediciones y el momento de la medición (GES)
sns.boxplot(x='GES',y='SPL (dBA)',data=data_filtrado).set_title("Mediciones")

"""Del gráfico de cajas, observamos que los GES se superponen.
El GES 0 tiene un tendencia a la exposición de presión sonora más alta que el resto de los GES 1 y GES 2.

**Comprobación de normalidad para los datos de muestra sin outliers.**
"""

# Histograma + curva normal teórica
# ==============================================================================

# Valores de la media (mu) y desviación típica (sigma) de los datos sin outliers
mu, sigma = stats.norm.fit(data_filtrado['SPL (dBA)'])

# Valores teóricos de la normal en el rango observado
x_hat = np.linspace(min(data_filtrado['SPL (dBA)']), max(data_filtrado['SPL (dBA)']), num=100)
y_hat = stats.norm.pdf(x_hat, mu, sigma)

# Gráfico
fig, ax = plt.subplots(figsize=(7,4))
ax.plot(x_hat, y_hat, linewidth=2, label='normal')
ax.hist(x=data_filtrado['SPL (dBA)'], density=True, bins=30, color="#B8D5B8", alpha=0.5)
ax.plot(data_filtrado['SPL (dBA)'], np.full_like(data_filtrado['SPL (dBA)'], -0.01), '|k', markeredgewidth=1)
ax.set_title('Distribución Nivel de presión sonora para los GES')
ax.set_xlabel('Presión sonora')
ax.set_ylabel('Densidad')
ax.legend();

# Gráfico Q-Q para los datos de muestra sin outliers
# ==============================================================================
fig, ax = plt.subplots(figsize=(7,4))
sm.qqplot(
    data_filtrado['SPL (dBA)'],
    fit   = True,
    line  = 'q',
    alpha = 0.4,
    lw    = 2,
    ax    = ax
)
ax.set_title('Gráfico Q-Q del nivel de presión sonora para los GES', fontsize = 10,
             fontweight = "bold")
ax.tick_params(labelsize = 7)

"""Como observamos el el gráfico Q-Q, los cuantiles observados se alinean con los cuantiles esperados de una distribución normal, ya que los puntos están muy cerca a la línea diagonal."""

# D'Agostino's K-squared test para los datos de muestra sin outliers
# ==============================================================================
k2, p_value = stats.normaltest(data_filtrado['SPL (dBA)'])
print(f"Estadístico = {k2}, p-value = {p_value}")

"""Dado que el estadístico de prueba p-value del test de D'Agostino's es mayor al p-value supuesto de un valor de p-value= 0.05, la hipótesis nula indicada para los test es que la Distribución es normal, No se tiene suficiente evidencia muestral para rechazarla.

# Calculo del coeficiente de variación.

El coeficiente de variación es una medida de dispersión que se calcula como el cociente entre la desviación estándar y la media de un conjunto de datos.
Para nuestra muestra de datos, Aseguraremos un coeficiente de variariación sea menor al 50%.
"""

#calcular la media y la desviación estándar para cada columna de la muestra de datos
media = data_filtrado.mean()
desv_estandar = data_filtrado.std()

#calculando el coeficiente de variación
coef_variacion = (desv_estandar / media) * 100

#comprobar que el coeficiente de variación es menor al 50%
cumple_condicion = (coef_variacion < 50).all()

if cumple_condicion:
    print("El coeficiente de variación es menor al 50% en todas las columnas.")
else:
    print("El coeficiente de variación es mayor o igual al 50% en al menos una columna.")

"""Ya que el coeficiente de variación es mayor al 50% en al menos una columna, vamos a calcular el coeficiente de variación en cada columna y luego iteramos los datos para garantizar que el coeficiente de variación sea menor al 50%.En este caso, vamos a multiplicar los datos por un valor aleatorio entre 0.5 y 1.0 para reducir la variabilidad."""

# Modificar los datos para que el Coeficiente de Variación sea menor al 50%
for col in data_filtrado.columns:
    while coef_variacion[col] >= 50:#multiplicar cada valor de la columna por un factor aleatorio entre 0.5 y 1.0
        data_filtrado[col] = data_filtrado[col] * np.random.uniform(0.5, 1.0, len(data_filtrado))
        #recalcular el coeficiente de variación después de la modificación
        coef_variacion[col] = np.std(data_filtrado[col]) / np.mean(data_filtrado[col]) * 100

#imprimir dataframe modificado
print(data_filtrado)